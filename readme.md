# Influx-Client 

对 `InfluxDBClient` 进行二次封装，提供简单的 Query、Insert 操作。

**注意：InfluxDB 的 Java 客户端仅支持 添加、查询数据操作，不支持管理数据。**

# 思路

## 添加数据

客户端通过写入点 `Point` 来创建 line protocol。添加数据时，需要设置写入点的表、标签、字段、时间戳。

将添加的数据封装为抽象对象，包含表、标签、字段、时间戳信息，除时间戳外均需重写。时间戳可选重写，默认为创建对象时的时间。

由于表中每条数据可以有不同的结构，所以表和对象并不是一一对应的。也就是说，一个表可以有多种对象。但是为了方便操作，一个对象只绑定给一个表。

需要注意，标签、字段在查询结果中无法标识，所以类中应当定义该类的标签、字段组。

InfluxDB 插入数据无需关注数据表是否存在，仅需直接插入数据即可。但是表不应随意自定，应当提供简单的约束（比如通过枚举）。

## 查询数据

客户端没有提供封装，需要通过 SQL 或 InfluxQL 查询。本客户端选择使用 SQL 作为查询语法。

封装查询 Wrapper，可以通过泛型类指定目标对象，从而通过方法调用动态构建 SQL；也可不指定泛型类，构建指定表、但不受字段约束的 SQL。

查询方法会返回结果流 `Stream<Object[]>`，Object 数组为按照顺序查询的字段的值。可以在构造查询语句时保存查询参数，再根据参数和顺序一一对应到对象中返回。

由于表和对象不是一一对应，所以查询方法应当指定一个泛型，用于封装为指定的对象。

# 实现

## 线程安全 暂未实现

要确保字段、标签类的操作是线程安全的。

目前的想法是自定义线程安全、维护存储顺序的类，通过**ConcurrentHashMap + 读写锁维护顺序**。

## 添加数据

通过 AbstractInsertObj 约束并提供获取标签、字段的键值对方法。需要作为 Influx 对象映射的类应继承该抽象类，并重写其中的 `tableName` 方法，在该方法中返回表名。

需要注意，该抽象类的子类若需要重写抽象类，要注意字段隐藏的问题，修改字段时尽量使用抽象类提供的方法修改，或通过 `super.obj=newObj` 的方式直接修改父类属性。

 

## 查询数据

通过 InfluxQueryWrapper 的静态方法创建查询链：

- create：创建匿名查询链，不会约束查询列名
- from：创建指定映射对象的查询链，查询的列名会收到该对象的约束
- fromBuild：创建指定映射对象的查询链并立刻构建，返回构建后的 SQL 语句

对于查询链，可以链式调用查询方法，从而设置查询参数。



# 包含类

## 基础类

### InfluxFields



### InfluxTags



### AbstractInfluxObj



## 工具类

### PointBuilder



### InfluxQueryWrapper

构建 Influx 查询 SQL 的工具类，允许通过链式调用传递查询参数，并调用方法构建查询语句、执行查询等。

该工具包含前置方法和终结方法，前置方法用于配置查询目标及条件，支持链式调用；终结方法会根据已有状态构造最终查询语句，并返回语句。

#### 构造方法

包含以下构造方法：

- 创建空查询链
- 从映射对象中提取信息
- 从映射对象中提取信息，同时直接构建

#### 添加查询目标列

查询目标列添加方法返回当前工具类实例本身，以支持链式调用。

构建查询参数提供以下方法：

- 传递映射对象添加
- 传递键添加（包括标签、字段）
- 根据当前引用对象添加

同时，在构建查询参数时，需要进行以下操作：

- 检查查询参数是否在映射对象中存在
- 确保查询参数顺序

#### 执行构建（终结方法）

执行构建方法会基于查询参数集合，构建查询 SQL 并返回。



# 当前问题

- measurement 隶属于对象，而不是类。应当通过注解方式将表与类绑定
- 由于以上条，InfluxQueryWrapper 现在引用的是对象，而不是指定的类。解决以上问题后，要重构 InfluxQueryWrapper。
- InfluxQueryWrapper 中，引用的映射对象，无法区分约束字段和要查询的字段。